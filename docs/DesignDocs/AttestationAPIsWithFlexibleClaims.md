Attestation APIs with Init- and Run-Time Claims Support
==========================

Motivation
------------

The Open Enclave SDK currently supports attestation APIs,
`oe_get_attestation_certificate_with_evidence_v2` and
`oe_verify_attestation_certificate_with_evidence_v2`, that
allow developers to obtain a self-signed certificate with
the enclave evidence embedded and to verify the certificate,
respectively. The latter API also outputs an array of claims,
allowing the developers to implement additional verification
logic. However, these APIs have following limitations:

- Lack of support of init-time custom claims

  According to [Open Enclave Init-time Configuration Interface](InitTimeConfigurationInterface.md),
  the support of init-time custom claims is desirable for the incoming SGX2
  features (i.e., `CONFIGID`). The `oe_get_attestation_certificate_with_evidence_v2`
  API does not allow developers to provide an init-time custom claim buffer as input.

- Limited support for run-time custom claims

  The notion of run-time custom claims is equivalent to the custom claims
  in the OE attestation plugin framework. The `oe_get_attestation_certificate_with_evidence_v2`
  API does not allow developers to provide custom claims as input.
  Instead, the API internally takes the input public key buffer as the custom claim by default.
  The `oe_verify_attestation_certificate_with_evidence_v2` then extracts the custom
  claim and verifies its value against the public key.

Specification
--------

This document proposes new APIs,
`oe_get_attestation_certificate_with_evidence_v3` and
`oe_verify_attestation_certificate_with_evidence_v3`, that
address the abovementioned limitations. Note that the certificate
generated by `oe_get_attestation_certificate_with_evidence_v3`
does not provide full backward compatibility to older versions
of verification APIs (e.g., `oe_verify_attestation_certificate_with_evidence_v2`
and `oe_verify_attestation_certificate`).

- oe_get_attestation_certificate_with_evidence_v3
  ```c
  /**
   * oe_get_attestation_certificate_with_evidence_v3
   *
   * Similar to oe_get_attestation_certificate_with_evidence_2, this function
   * generates a self-signed X.509 certificate with embedded evidence generated by
   * an attester plugin for the enclave. In addition, it allows an application to pass in
   * run-time and init-time custom claims.
   *
   * @experimental
   *
   * @param[in] format_id The format id of the evidence to be generated.
   * @param[in] subject_name A string containing an X.509 distinguished
   * name (DN) for customizing the generated certificate. This name is also used
   * as the issuer name because this is a self-signed certificate.
   * See RFC5280 (https://tools.ietf.org/html/rfc5280) for details.
   * Example value "CN=Open Enclave SDK,O=OESDK TLS,C=US"
   * @param[in] private_key A private key used to sign this certificate.
   * @param[in] private_key_size The size of the buffer above.
   * @param[in] public_key A public key used as the certificate's subject key.
   * @param[in] public_key_size The size of the buffer above.
   * @param[in] inittime_custom_claims_buffer An optional flat buffer representing the init-time
   * custom claims.
   * @param[in] inittime_custom_claims_buffer_size The size of the buffer above in bytes.
   * @param[in] runtime_custom_claims_buffer An optional flat buffer representing the run-time
   * cutom claims.
   * @param[in] runtime_custom_claims_buffer_size The size of the buffer above in bytes.
   * @param[in] optional_parameters The optional format-specific input parameters.
   * @param[in] optional_parameters_size The size of buffer above in bytes.
   * @param[out] output_certificate A pointer to buffer pointer.
   * @param[out] output_certificate_size The size of the buffer above.
   *
   * @return OE_OK The operation was successful.
   */
  oe_result_t oe_get_attestation_certificate_with_evidence_v3(
      const oe_uuid_t* format_id,
      const unsigned char* subject_name,
      const uint8_t* private_key,
      size_t private_key_size,
      const uint8_t* public_key,
      size_t public_key_size,
      const uint8_t* runtime_custom_claims_buffer,
      size_t runtime_custom_claims_buffer_size,
      const uint8_t* inittime_custom_claims_buffer,
      size_t inittime_custom_claims_buffer_size,
      const void* optional_parameters,
      size_t optional_parameters_size,
      uint8_t** output_certificate,
      size_t* output_certificate_size);

  ```
  The API introduces four arguments that allow developers to optionally
  pass in run- and init-time claims.
  - `runtime_custom_claims_buffer`
  - `runtime_custom_claims_buffer_size`
  - `inittime_custom_claims_buffer`
  - `inittime_custom_claims_buffer_size`

- oe_verify_attestation_certificate_with_evidence_v3
  ```c
  /**
   * oe_verify_attestation_certificate_with_evidence_v3
   *
   * This function is similar to
   * oe_verify_attestation_certificate_with_evidence_v2 that has the same
   * prototype but with the ability to verify a certificate generated by
   * oe_get_attestation_certificate_with_evidence_v3.
   *
   * @experimental
   *
   * @param[in] certificate_in_der A pointer to buffer holding certificate
   * contents in DER format.
   * @param[in] certificate_in_der_size The size of the buffer above.
   * @param[in] endorsements_buffer A pointer to buffer holding endorsements.
   * @param[in] endorsements_buffer_size The size of the buffer above.
   * @param[in] policies A pointer to buffer holding policies.
   * @param[in] policies_size The size of the buffer above.
   * @param[out] claims A double-pointer to buffer holding claims.
   * @param[out] claims_length The size of the buffer above.
   * @retval OE_OK Successful validation.
   * @retval OE_VERIFY_FAILED Quote failure.
   * @retval OE_INVALID_PARAMETER One or more invalid parameters.
   * @retval OE_FAILURE General failure.
   * @retval Other appropriate error code.
   */
  oe_result_t oe_verify_attestation_certificate_with_evidence_v3(
      const uint8_t* certificate_in_der,
      size_t certificate_in_der_size,
      const uint8_t* endorsements_buffer,
      size_t endorsements_buffer_size,
      const oe_policy_t* policies,
      size_t policies_size,
      oe_claim_t** claims,
      size_t* claims_length);
  ```
  The API does not introduce changes to the function prototype. The purpose of
  the API is to pair with `oe_get_attestation_certificate_with_evidence_v3`;
  i.e., only the API is able to verify the certificated generated via
  `oe_get_attestation_certificate_with_evidence_v3` with `runtime_custom_claims_buffer`
  or `inittime_custom_claims_buffer` supplied.

User Experience
--------

The following example demonstrates the use of proposed APIs.

```c
static const uint8_t inittime_custom_claims[] =
  { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

static const uint8_t runtime_custom_claims[] =
 { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x66, 0x77,
   0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff };

...

// Attester
uint8_t* output_certificate = nullptr;
size_t output_certificate_size = 0;

...

result = oe_get_attestation_certificate_with_evidence_v3(
     &format,
     (const unsigned char*)"CN=Open Enclave SDK,O=OESDK TLS,C=US",
     private_key,
     private_key_size,
     public_key,
     public_key_size,
     (uint8_t*)runtime_custom_claims,
     sizeof(runtime_custom_claims),
     (uint8_t*)inittime_custom_claims,
     sizeof(inittime_custom_claims),
     NULL,
     0,
     &output_certificate,
     &output_certificate_size);
OE_CHECK(result);

...

Send output_certificate to verifier

...

// Verifier (receive input_certificate)
oe_claim_t* claims = nullptr;
size_t claims_length = 0;

result = oe_verify_attestation_certificate_with_evidence_v3(
     input_certificate,
     input_certificate_size,
     nullptr,
     0,
     nullptr,
     0,
     &claims,
     &claims_length);
OE_CHECK(result);

// Implement verification logic against claims
for (size_t i = 0; i < claims_length; i++)
{
    if (strcmp(claim->name, OE_CLAIM_RUNTIME_CUSTOM_CLAIMS_BUFFER) == 0)
    {
        // Verify runtime custom claims
        oe_claim_t* claim = &claims[i];
        ...
    }
    else if (strcmp(claim->name, OE_CLAIM_INITTIME_CUSTOM_CLAIMS_BUFFER) == 0)
    {
       // Verify inittime custom claims
       oe_claim_t* claim = &claims[i];
       ...
    }
}
```

Design
--------

The new APIs follow the design outlined in
[Open Enclave Init-time Configuration Interface](InitTimeConfigurationInterface.md)
to support init-time custom claims.
The core idea of the design is to avoid breaking changes to the attestation plugin
framework. More specifically, the `oe_get_attestation_certificate_with_evidence_v3`
API appends the `inittime_custom_claims_buffer` to the evidence buffer, which is the output
of the `oe_get_evidence` API. After that, the API passes the new evidence buffer to the internal
API that is used to generate the self-signed certificate with the evidence embedded.
Similar to the run-time claims support, the API appends the `runtime_custom_claims_buffer` to the
`public_key` and passes the new buffer to the `oe_get_evidence` API.

```diff
oe_result_t oe_get_attestation_certificate_with_evidence_v3(
    const oe_uuid_t* format_id,
    const unsigned char* subject_name,
    const uint8_t* private_key,
    size_t private_key_size,
    const uint8_t* public_key,
    size_t public_key_size,
+   const uint8_t* runtime_custom_claims_buffer,
+   size_t runtime_custom_claims_buffer_size,
+   const uint8_t* inittime_custom_claims_buffer,
+   size_t inittime_custom_claims_buffer_size,
    const void* optional_parameters,
    size_t optional_parameters_size,
    uint8_t** output_certificate,
    size_t* output_certificate_size)
{
    oe_result_t result = OE_FAILURE;
    uint8_t* evidence_buffer = NULL;
    size_t evidence_buffer_size = 0;
+   uint8_t* custom_claims_buffer = NULL;
+   size_t custom_claims_buffer_size = 0;
+   uint8_t* evidence_with_inittime_custom_claims = NULL;
+   size_t evidence_with_inittime_custom_claims_size = 0;

    OE_TRACE_VERBOSE("Calling oe_get_attestation_certificate_with_evidence_v3");
    OE_TRACE_VERBOSE(
        "generate evidence with hash from public_key_size=%d public_key key "
        "=\n[%s]\n",
        public_key_size,
        public_key);

+   custom_claims_buffer_size = public_key_size + runtime_custom_claims_buffer_size;
+   custom_claims_buffer = oe_malloc(custom_claims_buffer_size);
+   if (!custom_claims_buffer)
+       OE_RAISE(OE_OUT_OF_MEMORY);

+   memcpy(custom_claims_buffer, public_key, public_key_size);
+   memcpy(
+       custom_claims_buffer + public_key_size,
+       runtime_custom_claims_buffer,
+       runtime_custom_claims_buffer_size);

    result = oe_get_evidence(
        format_id,
        OE_EVIDENCE_FLAGS_EMBED_FORMAT_ID,
-       public_key,
-       public_key_size,
+       custom_claims_buffer,
+       custom_claims_buffer_size,
        optional_parameters,
        optional_parameters_size,
        &evidence_buffer,
        &evidence_buffer_size,
        NULL,
        0);
    OE_CHECK_MSG(
        result, "oe_get_evidence failed with %s\n", oe_result_str(result));

+   evidence_with_inittime_custom_claims_size =
+       evidence_buffer_size + inittime_custom_claims_buffer_size;
+   evidence_with_inittime_custom_claims =
+       oe_malloc(evidence_with_inittime_custom_claims_size);
+   if (!evidence_with_inittime_custom_claims)
+       OE_RAISE(OE_OUT_OF_MEMORY);

+   memcpy(
+       evidence_with_inittime_custom_claims, evidence_buffer, evidence_buffer_size);
+   memcpy(
+       evidence_with_inittime_custom_claims + evidence_buffer_size,
+       inittime_custom_claims_buffer,
+       inittime_custom_claims_buffer_size);

    result = generate_x509_self_signed_certificate(
        oid_oe_evidence,
        sizeof(oid_oe_evidence),
        subject_name,
        private_key,
        private_key_size,
        public_key,
        public_key_size,
-       evidence_buffer,
-       evidence_buffer_size,
+       evidence_with_inittime_custom_claims,
+       evidence_with_inittime_custom_claims_size,
        output_certificate,
        output_certificate_size);
    OE_CHECK_MSG(
        result,
        "generate_x509_self_signed_certificate failed : %s",
        oe_result_str(result));

    OE_TRACE_VERBOSE(
        "self-signed certificate size = %d", *output_certificate_size);
    result = OE_OK;

done:
    oe_free_evidence(evidence_buffer);
+   oe_free(custom_claims_buffer);
+   oe_free(evidence_with_inittime_claims);

    return result;
}
```

The `oe_verify_attestation_certificate_with_evidence_v3` API is responsible
to extract run- and init-time claims from the certificate generated
by the `oe_get_attestation_certificate_with_evidence_v3`. The design also
introduces two new internal helper functions `_find_claim` and `_add_claims`
and two new claim types `OE_CLAIM_INITTIME_CLAIMS_BUFFER` and `OE_CLAIM_RUNTIME_CLAIMS_BUFFER`.
The output `claims` are expected to include two new claim types if present.

```diff
oe_result_t oe_verify_attestation_certificate_with_evidence_v3(
    const uint8_t* certificate_in_der,
    size_t certificate_in_der_size,
    const uint8_t* endorsements_buffer,
    size_t endorsements_buffer_size,
    const oe_policy_t* policies,
    size_t policies_size,
    oe_claim_t** claims,
    size_t* claims_length)
{
    oe_result_t result = OE_FAILURE;
    oe_cert_t cert = {0};
    uint8_t* report = NULL;
    size_t report_size = 0;
    oe_attestation_header_t* header = NULL;
    uint8_t* public_key_buffer = NULL;
    size_t public_key_buffer_size = KEY_BUFF_SIZE;

    const char* oid_array[] = {
        oid_oe_report, oid_new_oe_report, oid_oe_evidence, oid_new_oe_evidence};
    size_t oid_array_index = 0;
    size_t oid_array_count = OE_COUNTOF(oid_array);

    public_key_buffer = (uint8_t*)oe_malloc(KEY_BUFF_SIZE);
    if (!public_key_buffer)
        OE_RAISE(OE_OUT_OF_MEMORY);

    result =
        oe_cert_read_der(&cert, certificate_in_der, certificate_in_der_size);
    OE_CHECK_MSG(result, "certificate_in_der_size=%d", certificate_in_der_size);

    // validate the certificate signature
    result = oe_cert_verify(&cert, NULL, NULL, 0);
    OE_CHECK_MSG(
        result,
        "oe_cert_verify failed with error = %s\n",
        oe_result_str(result));

    //------------------------------------------------------------------------
    // Validate the evidence's trustworthiness
    // Verify the evidence to ensure its authenticity.
    //------------------------------------------------------------------------

    while (oid_array_index < oid_array_count)
    {
        oe_result_t find_result = oe_cert_find_extension(
            &cert,
            (const char*)oid_array[oid_array_index],
            &report,
            &report_size);

        if (find_result == OE_NOT_FOUND)
        {
            oid_array_index++;
            continue;
        }

        if (find_result == OE_OK)
            break;

        OE_RAISE_MSG(find_result, "oe_cert_find_extension failed", NULL);
    }

    // if there is no match
    if (oid_array_index == oid_array_count)
        OE_RAISE_MSG(
            OE_FAILURE, "No expected certificate extension matched", NULL);

    OE_TRACE_VERBOSE("oe_cert_find_extension() succeeded");

    if (oid_array_index >= 2) // oid_oe_evidence or oid_new_oe_evidence
    {
        // find the report version
        header = (oe_attestation_header_t*)report;
        if (header->version != OE_ATTESTATION_HEADER_VERSION)
            OE_RAISE_MSG(
                OE_INVALID_PARAMETER,
                "Invalid attestation header version %d, expected %d",
                header->version,
                OE_ATTESTATION_HEADER_VERSION);

+       size_t evidence_size =
+           sizeof(oe_attestation_header_t) + header->data_size;
        result = oe_verify_evidence(
            // The format ID parameter is NULL in this case, as the format ID is
            // embedded in the attestation header, which is always included in
            // an attestation certificate.
            NULL,
            report,
-           report_size,
+           evidence_size,
            endorsements_buffer,
            endorsements_buffer_size,
            policies,
            policies_size,
            claims,
            claims_length);

+       if (report_size > evidence_size)
+       {
+           size_t inittime_custom_claims_size = report_size - evidence_size;
+           uint8_t* inittime_custom_claims = report + evidence_size;
+           _add_claim(
+               claims,
+               claims_length,
+               OE_CLAIM_INITTIME_CUSTOM_CLAIMS_BUFFER,
+               sizeof(OE_CLAIM_INITTIME_CUSTOM_CLAIMS_BUFFER),
+               inittime_custom_claims,
+               inittime_custom_claims_size);
+       }
    }
    else // oid_oe_report or oid_new_oe_report
    {
        result = oe_verify_evidence(
            // The format ID is OE_FORMAT_UUID_LEGACY_REPORT_REMOTE for all OE
            // reports for remote attestation.
            &_uuid_legacy_report_remote,
            report,
            report_size,
            endorsements_buffer,
            endorsements_buffer_size,
            policies,
            policies_size,
            claims,
            claims_length);
    }

    OE_CHECK(result);
    OE_TRACE_VERBOSE("quote validation succeeded");

    // verify report data: hash(public key)
    // extract public key from the certificate
    oe_memset_s(public_key_buffer, KEY_BUFF_SIZE, 0, KEY_BUFF_SIZE);
    result = oe_cert_write_public_key_pem(
        &cert, public_key_buffer, &public_key_buffer_size);
    OE_CHECK(result);
    OE_TRACE_VERBOSE(
        "oe_cert_write_public_key_pem pub_key_buf_size=%d",
        public_key_buffer_size);

    result = _verify_public_key_claim(
        *claims, *claims_length, public_key_buffer, public_key_buffer_size);
    OE_CHECK(result);
    OE_TRACE_VERBOSE("user data: hash(public key) validation passed", NULL);

+   oe_claim_t* custom_claims_buffer;
+   if (_find_claim(
+           *claims,
+           *claims_length,
+           OE_CLAIM_CUSTOM_CLAIMS_BUFFER,
+           &custom_claims_buffer) == OE_OK)
+   {
+       if (custom_claims_buffer->value_size > public_key_buffer_size)
+       {
+           size_t runtime_custom_claims_size =
+               custom_claims_buffer->value_size - public_key_buffer_size;
+           uint8_t* runtime_custom_claims =
+               (uint8_t*)((uint64_t)custom_claims_buffer->value + public_key_buffer_size);
+           _add_claim(
+               claims,
+               claims_length,
+               OE_CLAIM_RUNTIME_CUSTOM_CLAIMS_BUFFER,
+               sizeof(OE_CLAIM_RUNTIME_CUSTOM_CLAIMS_BUFFER),
+               runtime_custom_claims,
+               runtime_custom_claims_size);
+       }
+   }

done:
    oe_free(public_key_buffer);
    oe_cert_free(&cert);
    oe_free(report);
    return result;
}
```

Discussion
--------

- Separation of custom claims and run-time custom claims.

  The current design introduces a separated `OE_CLAIM_RUNTIME_CUSTOM_CLAIMS_BUFFER`
  in addition to `OE_CLAIM_CUSTOM_CLAIMS_BUFFER`. Doing so allows for keeping
  the existing behavior of verifying public and providing more flexible use
  of run-time custom claims. The downside is confusing the use of custom claims.
  An alternative is
  - Rename the `OE_CLAIM_CUSTOM_CLAIMS_BUFFER` as `OE_CLAIM_RUNTIME_CUSTOM_CLAIMS_BUFFER`
  - Introduce `OE_CLAIM_RUNTIME_CUSTOM_CLAIMS_PUBLIC_KEY` (or simply `OE_CLAIM_CUSTOM_CLAIMS_PUBLIC_KEY`)

  This topic is open for discussion.

- Verification of init-time custom claims.

  The current design does not implement the logic of verifying init-time custom claims.
  This decision is letting the developers implement such logic. 
  Alternatively, the implementation can enforce the check of hash(`inittime_custom_claims`) against
  `CONFIGID` by default. This topic is also open for discussion.

- Lack of integrity protection with init-time custom claims.

  Based on the current design, the run-time custom claims are integrity-protected (i.e.,
  its hash is part of the evidence) while init-time custom claims rely on the
  assumption that the attester has already verified the claims based on the config id.
  This topic is open for discussion on whether this can be a concern.

- Increased size of the certificate.

  Appending run-time and init-time customs to existing buffers inevitably increases the size of the certificate.
  This issue could cause a problem if there is a limitation on the certificate size. This topic requires more discussion on
  the concerns and alternatives.

Authors
-------

- Ming-Wei Shih <mishih@microsoft.com>
